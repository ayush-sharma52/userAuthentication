{"ast":null,"code":"import { createSlice } from \"@reduxjs/toolkit\"; //this is a reducer() which will be called for manipulating the states in the store\n//this function is called by components using dispatch method\n//also called when the store is initialised\n\nconst initialCounterState = {\n  counter: 0,\n  showCounter: true\n}; // function counterReducer(state = initialCounterState, action) {\n//   if (action.type === \"Increment\")\n//     return {\n//       counter: state.counter + 1,\n//       showCounter: state.showCounter,\n//     };\n//   if (action.type === \"Decrement\")\n//     return {\n//       counter: state.counter - 1,\n//       showCounter: state.showCounter,\n//     };\n//   if (action.type === \"Increase\") {\n//     return {\n//       counter: state.counter + action.amount,\n//       showCounter: state.showCounter,\n//     };\n//   }\n//   if (action.type === \"Toggle\") {\n//     return {\n//       counter: state.counter,\n//       showCounter: !state.showCounter,\n//     };\n//   }\n//   return state;\n// }\n\nconst counterSlice = createSlice({\n  //here instead of a big state object we create slices of related or dependent states alsoreducer functions shortend\n  name: \"counter\",\n  initialState: initialCounterState,\n  reducers: {\n    //we pass all the reducing functions here in this object\n    Increment: state => {\n      state.counter++; //can mutate the previous state as toolkit  will handle it accordingly\n      //no need to again define other states and return a new object as it will merge this to them\n    },\n\n    Decrement(state) {\n      state.counter--;\n    },\n\n    //here when we dispatch this action we will pass another argument which will come here as below\n    Increase(state, action) {\n      state.counter += action.payload;\n    },\n\n    Toggle(state) {\n      state.showCounter = !state.showCounter;\n    }\n\n  }\n}); //now in the components which will call dispatch() we don't need to create a object give it type and all by self\n// and then pass it instead we will call the function provided in the slice's reducers object as 'counterActions.increment'\n// in the dispatch function argument and it will automatically create a required object to call that required ()\n\nexport const counterActions = counterSlice.actions;\nexport const counterReducers = counterSlice.reducer;","map":{"version":3,"names":["createSlice","initialCounterState","counter","showCounter","counterSlice","name","initialState","reducers","Increment","state","Decrement","Increase","action","payload","Toggle","counterActions","actions","counterReducers","reducer"],"sources":["D:/web/react.js/Redux(counter)/src/store/counter.js"],"sourcesContent":["import { createSlice } from \"@reduxjs/toolkit\";\r\n\r\n//this is a reducer() which will be called for manipulating the states in the store\r\n//this function is called by components using dispatch method\r\n//also called when the store is initialised\r\n\r\nconst initialCounterState = { counter: 0, showCounter: true };\r\n// function counterReducer(state = initialCounterState, action) {\r\n//   if (action.type === \"Increment\")\r\n//     return {\r\n//       counter: state.counter + 1,\r\n//       showCounter: state.showCounter,\r\n//     };\r\n//   if (action.type === \"Decrement\")\r\n//     return {\r\n//       counter: state.counter - 1,\r\n//       showCounter: state.showCounter,\r\n//     };\r\n//   if (action.type === \"Increase\") {\r\n//     return {\r\n//       counter: state.counter + action.amount,\r\n//       showCounter: state.showCounter,\r\n//     };\r\n//   }\r\n//   if (action.type === \"Toggle\") {\r\n//     return {\r\n//       counter: state.counter,\r\n//       showCounter: !state.showCounter,\r\n//     };\r\n//   }\r\n\r\n//   return state;\r\n// }\r\n\r\nconst counterSlice = createSlice({\r\n  //here instead of a big state object we create slices of related or dependent states alsoreducer functions shortend\r\n  name: \"counter\",\r\n  initialState: initialCounterState,\r\n  reducers: {\r\n    //we pass all the reducing functions here in this object\r\n    Increment: (state) => {\r\n      state.counter++; //can mutate the previous state as toolkit  will handle it accordingly\r\n      //no need to again define other states and return a new object as it will merge this to them\r\n    },\r\n    Decrement(state) {\r\n      state.counter--;\r\n    },\r\n    //here when we dispatch this action we will pass another argument which will come here as below\r\n    Increase(state, action) {\r\n      state.counter += action.payload;\r\n    },\r\n    Toggle(state) {\r\n      state.showCounter = !state.showCounter;\r\n    },\r\n  },\r\n});\r\n\r\n//now in the components which will call dispatch() we don't need to create a object give it type and all by self\r\n// and then pass it instead we will call the function provided in the slice's reducers object as 'counterActions.increment'\r\n// in the dispatch function argument and it will automatically create a required object to call that required ()\r\nexport const counterActions = counterSlice.actions;\r\nexport const counterReducers = counterSlice.reducer;\r\n\r\n"],"mappings":"AAAA,SAASA,WAAT,QAA4B,kBAA5B,C,CAEA;AACA;AACA;;AAEA,MAAMC,mBAAmB,GAAG;EAAEC,OAAO,EAAE,CAAX;EAAcC,WAAW,EAAE;AAA3B,CAA5B,C,CACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA,MAAMC,YAAY,GAAGJ,WAAW,CAAC;EAC/B;EACAK,IAAI,EAAE,SAFyB;EAG/BC,YAAY,EAAEL,mBAHiB;EAI/BM,QAAQ,EAAE;IACR;IACAC,SAAS,EAAGC,KAAD,IAAW;MACpBA,KAAK,CAACP,OAAN,GADoB,CACH;MACjB;IACD,CALO;;IAMRQ,SAAS,CAACD,KAAD,EAAQ;MACfA,KAAK,CAACP,OAAN;IACD,CARO;;IASR;IACAS,QAAQ,CAACF,KAAD,EAAQG,MAAR,EAAgB;MACtBH,KAAK,CAACP,OAAN,IAAiBU,MAAM,CAACC,OAAxB;IACD,CAZO;;IAaRC,MAAM,CAACL,KAAD,EAAQ;MACZA,KAAK,CAACN,WAAN,GAAoB,CAACM,KAAK,CAACN,WAA3B;IACD;;EAfO;AAJqB,CAAD,CAAhC,C,CAuBA;AACA;AACA;;AACA,OAAO,MAAMY,cAAc,GAAGX,YAAY,CAACY,OAApC;AACP,OAAO,MAAMC,eAAe,GAAGb,YAAY,CAACc,OAArC"},"metadata":{},"sourceType":"module"}